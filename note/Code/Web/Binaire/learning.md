Sur ce guide on va vous expliquer le binaire  

Pensez le binaire comme un tableau,
- 8 colonnes (pour cr√©er un octet (il est utile de compte √† plus de 1...))
- 2 lignes
- de la droite vers la gauche √©crivez les puissance de 2

# Origine du binaire
Le binaire est le mode de comptage non plus en base 5 ([Syst√®me quinaire](https://fr.wikipedia.org/wiki/Syst√®me_quinaire))

base 9 ( En Chine et au Japon, on peut compter jusqu'√† neuf sur chaque main [dactylonomie](https://fr.wikipedia.org/wiki/Dactylonomie)) 

base __**10 (celle que nous connaissont en Europe)**__

base 12 ([Syst√®me duod√©cimal](https://fr.wikipedia.org/wiki/Syst√®me_duod√©cimal) forme de dactylonomie mais en utilisant phalanges) 

__**mais en base 2 li√© √† sa propri√©t√© physique**__ !  
- Le binaire devant √™tre stock√©, il est grav√© soit sur un support physique (disques en m√©tal, en verre ou en c√©ramique empil√©s) (exemple un [disque dur HDD](https://fr.wikipedia.org/wiki/Disque_dur) via magn√©tisme sur un disque m√©canique en rotation)  
- Ou alors grav√© de mani√®re "√©lectrique" [m√©moire flash](https://fr.wikipedia.org/wiki/M√©moire_flash) (NVME & SSD / Clef USB / RAM) en stockant dans un [transistor](https://fr.wikipedia.org/wiki/Transistor) / [MOS](https://fr.wikipedia.org/wiki/Transistor_√†_effet_de_champ_√†_grille_m√©tal-oxyde) poss√©dant une grille flottante enfouie dans la puce. L'information est stock√©e gr√¢ce au pi√©geage d'√©lectrons dans cette grille flottante ([M√©moire EEPROM "Electrically-erasable programmable read-only memory"](https://fr.wikipedia.org/wiki/Electrically-erasable_programmable_read-only_memory))

# Comment √©crire un chiffre en binaire

Dans ces m√©moires, on y stock nos donn√©s de mani√®re logique, sans quoi, impossible de retrouver quoi que ce soit ...

- 8 colonnes et 2 lignes
- de la droite vers la gauche √©crivez les puissance de 2

```
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 
|     |    |    |    |   |   |   |   |
```
(Vous pouvez √©crire dans les tableaux sur [doc.Altherneum.fr/cours/binaire](https://doc.Altherneum.fr/cours/binaire))

- Une case vide ne vaut rien, elle n'ajoute rien au r√©sultat
- Une case avec un bite stock√© rajoute la valeur assign√© au r√©sultat

Reprennons notre tableau
```
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 
|     |    |    |    |   |   |   |   |  
vaut 0, car rien n'est stock√©
```
```
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 
|     |    |    |    |   |   |   | X |
Celui-ci contient un bit, positionn√© sur "1", le r√©sultat est donc 1 üò±
```

```
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 
|     |    |    |    | X |   |   | X |
Ici il y a 8 + 1 = 9
```

Comment √©crire 25 ?  
- Prennez les plus gros chiffres en premier (de gauche √† droite)
- Cocher des bits / cases tant que le r√©sultat total ne vaut pas 25
```
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | 
|     |    |    | X  | X |   |   | X |
16 + 8 + 1 = 25 ! ü§Ø
```

Vous pouvez aussi le voire comme une rang√© que vous remplissez petit √† petit ([lehollandaisvolant.net](https://lehollandaisvolant.net/tuto/bin/))
```
1	1	simple !
2	10	Le premier rang a atteint le maximum autoris√© ! Qu'√† cela ne tienne, on passe au rang suivant. On met le second √† 1 et on remet le premier √† 0.
3	11	On re-remplit le rang 1.
4	100	Le rang 1 est plein, mais le 2 aussi ! On passe donc au troisi√®me et on remet les pr√©c√©dents √† 0 (comme on le fait lorsque l'on passe de 0999 √† 1000, par exemple).
5	101	On proc√®de de m√™me.
6	110
7	111
8	1000	On entame le quatri√®me rang.
9	1001	On recommence au premier‚Ä¶
10	1010	On rempli les rangs.
```

Ou encore en d√©componsant le calcul en puissance de 2 (Et oui), des divisons, des bouliers "m√©canique", ...

- [sebastienguillon.com /test/javascript /convertisseur](https://sebastienguillon.com/test/javascript/convertisseur.html) (Convertisseur binaire)

## Additionner, soustraire, ... en binaire
### Additionner
- L'addition en base 2 fonctionne comme l'addition en d√©cimal, mais attention car en binaire, `1 + 1 = 10`
- il faut donc placer 0 et mettre une retenue de 1 sur le bit suivant. Il faut que les nombres √† additionner soient de m√™me taille

```
1 + 1 = 10 (On ajoute une retenue)
1 + 0 = 1
0 + 1 = 1
0 + 0 = 0
```

```
  0 0 0¬π 1¬π 1 0¬π 0¬π 1
+ 0 0 0  1  1 0  1  1
= 0 0 1  1  0 1  0  0
```

![addition binaire](https://www.maxicours.com/se/media/img/5/7/9/2/579261.png)

- [maxicours.com /se/cours/ effectuer-des-operations-en-binaire](https://www.maxicours.com/se/cours/effectuer-des-operations-en-binaire)

## Soustraire
## Multiplier
## Diviser

# IP & masque r√©seau
- Voire [cours IP](https://doc.altherneum.fr/cours/ip)
- [Cours r√©seau](https://doc.altherneum.fr/cours/network)

## Transformer en binaire
Pour calculer une adresse IP avec son masque on transforme les deux valeurs en binaire
```
192       . 168       . 1         . 116
1100 0000 . 1010 1000 . 0000 0001 . 0111 0100

255       . 255       . 255       . 0
1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
```

### Lecture des adresses r√©seau et client
On peut d√©j√† d√©terminer l'adresse r√©seau et l'adresse des postes de ce r√©seau
```
  1100 0000 . 1010 1000 . 0000 0001 . 0111 0100
+ 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
= { Adresse . r√©seau    .         } . { PC     }
```

### Porte logique ET
Par la suite on applique un ET logique  
(Attention on ne fait pas une addition mais une porte logique ET)
```
1 + 1 = 1
1 + 0 = 0
0 + 1 = 0
0 + 0 = 0
```

Ce qui donne
```
  1100 0000 . 1010 1000 . 0000 0001 . 0111 0100
+ 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
= 1100 0000 . 1010 1000 . 0000 0001 . 0000 0000
```

```
1100 0000 . 1010 1000 . 0000 0001 . 0000 0000
192       . 168       . 1         . 0

192.168.1.0 est l'adresse r√©seau
L'adresse IP et masque : 192.168.1.116/24
```

## Calculer les sous r√©seaux et nombre d'h√¥tes
### D√©terminer le nombre de sous r√©seau
- D√©terminer la classe de l'adresse IP par d√©faut  
(Voire [cours IP # Masque](https://doc.altherneum.fr/cours/ip.html#Masque) et [cours IP # IPv4](https://doc.altherneum.fr/cours/ip.html#IPv4))
- Soustraire le masque donn√©
- Ce qui donne `2 ^ [R√©sultat]` sous r√©seaux possibles

#### Exemple
```
192       . 168       . 1         . 116
1100 0000 . 1010 1000 . 0000 0001 . 0111 0100

255       . 255       . 255       . 240
1111 1111 . 1111 1111 . 1111 1111 . 1111 0000
```

- Ici la classe par d√©faut d'une adresse en 192.xxx. .... est une classe C (`/24`)
- Et le masque donn√© est (`/28`)
- `28 - 24 = 4`, le nombre de sous r√©seau maximum possible est donc `2 ^ 4`

#### Exemple 2
```
192       . 168       . 1         . 116
1100 0000 . 1010 1000 . 0000 0001 . 0111 0100

255       . 255       . 255       . 0
1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
```
- Classe C (`/24`)
- Mois le masque (`/24`)
- `24 - 24 = 0` Il n'y a qu'un seul sous r√©seau possible

### D√©terminer le nombre d'h√¥tes
- D√©terminer le nombre de bits √† 0 du masque
- Le nombre d'h√¥te est donc `2 ^ [Valeur] - 2`

#### Exemple 3
```
192       . 168       . 1         . 116
1100 0000 . 1010 1000 . 0000 0001 . 0111 0100

255       . 255       . 255       . 240
1111 1111 . 1111 1111 . 1111 1111 . 1111 0000
```

- Ici le masque est compos√© de 4 bits avec une valeur de 0 √† sa fin
- Ce qui donne `2 ^ 4 - 2` = 14 h√¥tes maximum possible

#### Exemple 4
```
192       . 168       . 1         . 116
1100 0000 . 1010 1000 . 0000 0001 . 0111 0100

255       . 255       . 255       . 0
1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
```
- Ici il y a 8 bits √† 0 sur le masque
- `2 ^ 8 - 2` = 254 adresses disponibles pour connecter des h√¥tes

### Pi√®ge de l'adresse broadcast

Pour savoir si une adresse est disponible ou une adresse de broadcast : 
- Adresse √† v√©rifier : `172.16.3.255`(`/23`)
- Adresse r√©seau : `172.16.2.0`(`/23`)
```
1010 1100 . 0001 0000 . 0000 0010 . 1111 1111    IP
1111 1111 . 1111 1111 . 1111 1110 . 0000 0000    Masque
1010 1100 . 0001 0000 . 0000 0010 . 0000 0000    R√©sultat condition ET
```

Cela donne donc
- `172 . 16 . 2 . 0` en adresse r√©seau
- `2 ^ 9 - 2` = 510 adresses disponibles
- `172 . 16 . 2 . 255` est toujours dans le m√™me r√©seau et laisse encore `510-255` = 255 adresses libres
- La derni√®re adresse libre pour un h√¥te est donc `172 . 16 . 3 . 254`
- Le broadcast est donc sur `172 . 16 . 3 . 255`

### Cr√©er un r√©seau de taille fixe
#### Exemple 5
```
| 2^9 | 2^8 | 2^7 |2^6 |2^5 |2^4 |2^3|2^2|2^1|2^0| Nombres d'h√¥tes possibles
| 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
|  x  |     |     |    |    |    |   |   |   |   |
```

`2 ^ 9 - 2` = 510
Le masque va permettre de stocker 510 h√¥tes

#### Exemple 6
```
|2^11|2^10| 2^9 | 2^8 | 2^7 |2^6 |2^5 |2^4 |2^3|2^2|2^1|2^0|
|2048|1024| 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
|    | X  |     |     |     | x  |    |    | X | X | X |   |
```
`010001001110 = 1102`, donc `1102 - 2` = 1100 adresses possibles 
- Cela va permettre de cr√©er un r√©seau de 1100 postes

# Octets vs Bits vs Bytes
- Bit = 1 ou 0
- Byte est la quantit√© de donn√©e

- Exemple 8 bytes font un octet compos√©s de bits

- Les bits ne sont pas utilis√©s pour repr√©senter les capacit√©s de stockage
- Un Byte, quant √† lui, est la plus petite quantit√© de donn√©es et d√©signe une unit√© de m√©moire
- Un octet s'√©crit avec 8 bits
- Une image d'un octet p√®se donc 8 bytes 

# Cr√©er du text

# H√©xad√©cimale
